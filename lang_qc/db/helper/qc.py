# Copyright (c) 2023 Genome Research Ltd.
#
# Authors:
#  Kieron Taylor <kt19@sanger.ac.uk>
#
# This file is part of npg_langqc.
#
# npg_langqc is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>.

from typing import Dict, List

from pydantic import BaseModel, Field
from sqlalchemy import select
from sqlalchemy.orm import Session, selectinload

from lang_qc.db.qc_schema import QcState as QcStateDb
from lang_qc.db.qc_schema import QcStateDict, QcType, SeqProduct, User
from lang_qc.models.qc_state import QcState


class BulkQcFetch(BaseModel):

    session: Session = Field(
        title="SQLAlchemy Session",
        description="A SQLAlchemy Session for the LangQC database",
    )

    class Config:
        arbitrary_types_allowed = True

    def query_by_id_list(self, ids: List) -> Dict[str, list[QcState]]:
        """
        Fetches sequencing products with matching product IDs (checksums).
        Invalid or nonexistent IDs will be omitted from the return value.

        ids - a list of SHA256 strings generated by npg_id_generation

        Returns a dictionary of SeqProduct results with pre-loaded joins for QC
        state reporting.
        """

        seq_prods = self.get_qc_state_by_id_list(ids)
        return self.extract_qc(seq_prods)

    def get_qc_state_by_id_list(self, ids) -> List[SeqProduct]:
        """
        Generate and execute a query for SeqProducts from a list
        of product IDs. Prefetch all related QC states.
        """
        query = (
            select(SeqProduct)
            .join(QcStateDb)
            .join(QcType)
            .join(QcStateDict)
            .join(User)
            .where(SeqProduct.id_product.in_(ids))
            .options(
                selectinload(SeqProduct.qc_state).options(
                    selectinload(QcStateDb.qc_type),
                    selectinload(QcStateDb.user),
                    selectinload(QcStateDb.qc_state_dict),
                )
            )
        )

        return self.session.execute(query).scalars().all()

    def extract_qc(
        self, seq_products: List[SeqProduct]
    ) -> Dict[str, Dict[str, QcState]]:
        """
        Given a list of SeqProducts, convert all related QC states into
        QcState format and index them by their product checksum and QC type
        """
        response = dict()
        for product in seq_products:
            response[product.id_product] = []
            for qc in product.qc_state:
                response[product.id_product].append(QcState.from_orm(qc))

        return response
