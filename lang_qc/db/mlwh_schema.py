# -*- coding: utf-8 -*-
#
# Copyright Â© 2023 Genome Research Ltd. All rights reserved.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# @author mgcam <mg8@sanger.ac.uk>

import datetime
import decimal
from typing import List, Optional

from sqlalchemy import (
    DECIMAL,
    BigInteger,
    Computed,
    DateTime,
    Float,
    ForeignKeyConstraint,
    Index,
    Integer,
    String,
    text,
)
from sqlalchemy.dialects.mysql import (
    BIGINT,
    CHAR,
    DATETIME,
    INTEGER,
    SMALLINT,
    TEXT,
    TINYINT,
    VARCHAR,
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship


class Base(DeclarativeBase):
    def _get_row_description(self, fields: list[str]) -> str:
        """
        Returns a printable representation of the database table row. Interprets
        a list of strings given as the `fields` argument as a list of column
        names. Combines the name of the class, names of the given columns
        and respective values into a row description. The columns for which
        the row has a NULL value are omitted from the description.
        """

        pairs = []
        for name in fields:
            value = self.__getattribute__(name)
            if value is not None:
                pairs.append(f"{name}={value}")
        description = ", ".join(pairs)
        return f"{self.__module__}.{self.__class__.__name__}: {description}"


class Sample(Base):
    __tablename__ = "sample"
    __table_args__ = (
        Index("index_sample_on_id_lims", "id_lims"),
        Index(
            "index_sample_on_id_lims_and_id_sample_lims",
            "id_lims",
            "id_sample_lims",
            unique=True,
        ),
        Index("index_sample_on_id_sample_lims", "id_sample_lims"),
        Index(
            "index_sample_on_id_sample_lims_and_id_lims",
            "id_sample_lims",
            "id_lims",
            unique=True,
        ),
        Index("index_sample_on_sanger_sample_id", "sanger_sample_id"),
        Index("index_sample_on_supplier_name", "supplier_name"),
        Index("sample_accession_number_index", "accession_number"),
        Index("sample_name_index", "name"),
        Index("sample_uuid_sample_lims_index", "uuid_sample_lims", unique=True),
        {"mysql_collate": "utf8_unicode_ci"},
    )

    id_sample_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        autoincrement=True,
        comment="Internal to this database id, value can change",
    )
    id_lims: Mapped[str] = mapped_column(
        VARCHAR(10),
        nullable=False,
        comment="LIM system identifier, e.g. CLARITY-GCLP, SEQSCAPE",
    )
    uuid_sample_lims: Mapped[str] = mapped_column(
        VARCHAR(36), nullable=False, comment="LIMS-specific sample uuid"
    )
    id_sample_lims: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="LIMS-specific sample identifier"
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of last update"
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of warehouse update"
    )
    consent_withdrawn: Mapped[int] = mapped_column(
        TINYINT(1), server_default=text("'0'")
    )
    deleted_at: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of sample deletion"
    )
    created: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of sample creation"
    )
    name: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    reference_genome: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    organism: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    accession_number: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="A unique identifier generated by the INSDC"
    )
    common_name: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    description: Mapped[Optional[str]] = mapped_column(TEXT)
    taxon_id: Mapped[Optional[int]] = mapped_column(INTEGER)
    father: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    mother: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    replicate: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ethnicity: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    gender: Mapped[Optional[str]] = mapped_column(VARCHAR(20))
    cohort: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    country_of_origin: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    geographical_region: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    sanger_sample_id: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    control: Mapped[Optional[int]] = mapped_column(TINYINT(1))
    supplier_name: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    public_name: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    sample_visibility: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    strain: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    donor_id: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    phenotype: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="The phenotype of the sample as described in Sequencescape",
    )
    developmental_stage: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Developmental Stage"
    )
    control_type: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    sibling: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    is_resubmitted: Mapped[Optional[int]] = mapped_column(TINYINT(1))
    date_of_sample_collection: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    date_of_sample_extraction: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    extraction_method: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    purified: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    purification_method: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    customer_measured_concentration: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    concentration_determined_by: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    sample_type: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    storage_conditions: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    genotype: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    age: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    cell_type: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    disease_state: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    compound: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    dose: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    immunoprecipitate: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    growth_condition: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    organism_part: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    time_point: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    disease: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    subject: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    treatment: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    date_of_consent_withdrawn: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime
    )
    marked_as_consent_withdrawn_by: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    customer_measured_volume: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    gc_content: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    dna_source: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    priority_level: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Priority level eg Medium, High etc"
    )

    pac_bio_run: Mapped[List["PacBioRun"]] = relationship(
        "PacBioRun", back_populates="sample"
    )


class Aliquot(Base):
    __tablename__ = "aliquot"
    __table_args__ = ({"mysql_collate": "utf8_unicode_ci"},)

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
    id_lims: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The LIMS system that the aliquot was created in",
    )
    aliquot_uuid: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The UUID of the aliquot in the LIMS system",
    )
    aliquot_type: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="The type of the aliquot"
    )
    source_type: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="The type of the source of the aliquot"
    )
    source_barcode: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="The barcode of the source of the aliquot"
    )
    sample_name: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The name of the sample that the aliquot was created from",
    )
    used_by_type: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The type of the entity that the aliquot is used by",
    )
    used_by_barcode: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The barcode of the entity that the aliquot is used by",
    )
    volume: Mapped[decimal.Decimal] = mapped_column(
        DECIMAL(10, 2), comment="The volume of the aliquot (uL)"
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DATETIME(fsp=6),
        nullable=False,
        comment="The date and time that the aliquot was last updated",
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DATETIME(fsp=6),
        nullable=False,
        comment="The date and time that the aliquot was recorded",
    )
    created_at: Mapped[datetime.datetime] = mapped_column(
        DATETIME(fsp=6),
        nullable=False,
        comment="The date and time that this record was created",
    )
    concentration: Mapped[Optional[decimal.Decimal]] = mapped_column(
        DECIMAL(10, 2), comment="The concentration of the aliquot (ng/ul)"
    )
    insert_size: Mapped[Optional[int]] = mapped_column(
        Integer, comment="The size of the insert in base pairs"
    )


class Study(Base):
    __tablename__ = "study"
    __table_args__ = (
        Index("index_study_on_id_study_lims", "id_study_lims"),
        Index("study_accession_number_index", "accession_number"),
        Index(
            "study_id_lims_id_study_lims_index", "id_lims", "id_study_lims", unique=True
        ),
        Index("study_name_index", "name"),
        Index("study_uuid_study_lims_index", "uuid_study_lims", unique=True),
        {"mysql_collate": "utf8_unicode_ci"},
    )

    id_study_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        autoincrement=True,
        comment="Internal to this database id, value can change",
    )
    id_lims: Mapped[str] = mapped_column(
        VARCHAR(10),
        nullable=False,
        comment="LIM system identifier, e.g. GCLP-CLARITY, SEQSCAPE",
    )
    id_study_lims: Mapped[str] = mapped_column(
        VARCHAR(20), nullable=False, comment="LIMS-specific study identifier"
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of last update"
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of warehouse update"
    )
    remove_x_and_autosomes: Mapped[int] = mapped_column(
        TINYINT(1), nullable=False, server_default=text("'0'")
    )
    aligned: Mapped[int] = mapped_column(
        TINYINT(1), nullable=False, server_default=text("'1'")
    )
    separate_y_chromosome_data: Mapped[int] = mapped_column(
        TINYINT(1), nullable=False, server_default=text("'0'")
    )
    uuid_study_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(36), comment="LIMS-specific study uuid"
    )
    deleted_at: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of study deletion"
    )
    created: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of study creation"
    )
    name: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    reference_genome: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ethically_approved: Mapped[Optional[int]] = mapped_column(TINYINT(1))
    faculty_sponsor: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    state: Mapped[Optional[str]] = mapped_column(VARCHAR(50))
    study_type: Mapped[Optional[str]] = mapped_column(VARCHAR(50))
    abstract: Mapped[Optional[str]] = mapped_column(TEXT)
    abbreviation: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    accession_number: Mapped[Optional[str]] = mapped_column(VARCHAR(50))
    description: Mapped[Optional[str]] = mapped_column(TEXT)
    contains_human_dna: Mapped[Optional[int]] = mapped_column(
        TINYINT(1), comment="Lane may contain human DNA"
    )
    contaminated_human_dna: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Human DNA in the lane is a contaminant and should be removed",
    )
    data_release_strategy: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    data_release_sort_of_study: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ena_project_id: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    study_title: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    study_visibility: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ega_dac_accession_number: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    array_express_accession_number: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ega_policy_accession_number: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    data_release_timing: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    data_release_delay_period: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    data_release_delay_reason: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    data_access_group: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    prelim_id: Mapped[Optional[str]] = mapped_column(
        VARCHAR(20), comment="The preliminary study id prior to entry into the LIMS"
    )
    hmdmc_number: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="The Human Materials and Data Management Committee approval "
        "number(s) for the study.",
    )
    data_destination: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="The data destination type(s) for the study. "
        "It could be 'standard', '14mg' or 'gseq'. This may be extended, "
        "if Sanger gains more external customers. It can contain multiply "
        "destinations separated by a space.",
    )
    s3_email_list: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    data_deletion_period: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    contaminated_human_data_access_group: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255)
    )
    programme: Mapped[Optional[str]] = mapped_column(VARCHAR(255))

    pac_bio_run: Mapped[List["PacBioRun"]] = relationship(
        "PacBioRun", back_populates="study"
    )


class PacBioRun(Base):
    __tablename__ = "pac_bio_run"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_sample_tmp"],
            ["sample.id_sample_tmp"],
            ondelete="RESTRICT",
            onupdate="RESTRICT",
            name="fk_pac_bio_run_to_sample",
        ),
        ForeignKeyConstraint(
            ["id_study_tmp"],
            ["study.id_study_tmp"],
            ondelete="RESTRICT",
            onupdate="RESTRICT",
            name="fk_pac_bio_run_to_study",
        ),
        Index("fk_pac_bio_run_to_sample", "id_sample_tmp"),
        Index("fk_pac_bio_run_to_study", "id_study_tmp"),
        Index(
            "unique_pac_bio_entry",
            "id_lims",
            "id_pac_bio_run_lims",
            "well_label",
            "comparable_tag_identifier",
            "comparable_tag2_identifier",
            "plate_number",
            unique=True,
        ),
        {"mysql_collate": "utf8_unicode_ci"},
    )

    id_pac_bio_tmp: Mapped[int] = mapped_column(
        Integer, primary_key=True, autoincrement=True
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of last update"
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of warehouse update"
    )
    id_sample_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Sample id, see "sample.id_sample_tmp"'
    )
    id_study_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Sample id, see "study.id_study_tmp"'
    )
    id_pac_bio_run_lims: Mapped[str] = mapped_column(
        VARCHAR(20),
        nullable=False,
        comment="Lims specific identifier for the pacbio run",
    )
    cost_code: Mapped[str] = mapped_column(
        VARCHAR(20), nullable=False, comment="Valid WTSI cost-code"
    )
    id_lims: Mapped[str] = mapped_column(
        VARCHAR(10), nullable=False, comment="LIM system identifier"
    )
    plate_uuid_lims: Mapped[str] = mapped_column(
        VARCHAR(36), nullable=False, comment="The plate uuid"
    )
    well_label: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The well identifier for the plate, A1-H12",
    )
    well_uuid_lims: Mapped[str] = mapped_column(
        VARCHAR(36), nullable=False, comment="The well uuid"
    )
    pac_bio_library_tube_id_lims: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="LIMS specific identifier for originating library tube",
    )
    pac_bio_library_tube_uuid: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The uuid for the originating library tube",
    )
    pac_bio_library_tube_name: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="The name of the originating library tube"
    )
    pac_bio_run_uuid: Mapped[Optional[str]] = mapped_column(
        VARCHAR(36), comment="Uuid identifier for the pacbio run"
    )
    tag_identifier: Mapped[Optional[str]] = mapped_column(
        VARCHAR(30), comment="Tag index within tag set, NULL if untagged"
    )
    tag_sequence: Mapped[Optional[str]] = mapped_column(
        VARCHAR(30), comment="Tag sequence for tag"
    )
    tag_set_id_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(20), comment="LIMs-specific identifier of the tag set for tag"
    )
    tag_set_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(100), comment="WTSI-wide tag set name for tag"
    )
    tag2_sequence: Mapped[Optional[str]] = mapped_column(VARCHAR(30))
    tag2_set_id_lims: Mapped[Optional[str]] = mapped_column(VARCHAR(20))
    tag2_set_name: Mapped[Optional[str]] = mapped_column(VARCHAR(100))
    tag2_identifier: Mapped[Optional[str]] = mapped_column(VARCHAR(30))
    plate_barcode: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="The human readable barcode for the plate loaded onto the machine",
    )
    pac_bio_library_tube_legacy_id: Mapped[Optional[int]] = mapped_column(
        Integer, comment="Legacy library_id for backwards compatibility."
    )
    library_created_at: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of library creation"
    )
    pac_bio_run_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Name of the run"
    )
    pipeline_id_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(60),
        comment="LIMS-specific pipeline identifier that unambiguously defines "
        "library type (eg. Sequel-v1, IsoSeq-v1)",
    )
    comparable_tag_identifier: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), Computed("(ifnull(`tag_identifier`,-(1)))", persisted=False)
    )
    comparable_tag2_identifier: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), Computed("(ifnull(`tag2_identifier`,-(1)))", persisted=False)
    )
    plate_number: Mapped[Optional[int]] = mapped_column(
        Integer,
        comment="The number of the plate that goes onto the sequencing machine. "
        "Necessary as an identifier for multi-plate support.",
    )
    pac_bio_library_tube_barcode: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="The barcode of the originating library tube"
    )

    sample: Mapped["Sample"] = relationship("Sample", back_populates="pac_bio_run")
    study: Mapped["Study"] = relationship("Study", back_populates="pac_bio_run")
    pac_bio_product_metrics: Mapped[List["PacBioProductMetrics"]] = relationship(
        "PacBioProductMetrics", back_populates="pac_bio_run"
    )


class PacBioProductMetrics(Base):
    __tablename__ = "pac_bio_product_metrics"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_pac_bio_rw_metrics_tmp"],
            ["pac_bio_run_well_metrics.id_pac_bio_rw_metrics_tmp"],
            ondelete="CASCADE",
            name="pac_bio_product_metrics_to_rwm_fk",
        ),
        ForeignKeyConstraint(
            ["id_pac_bio_tmp"],
            ["pac_bio_run.id_pac_bio_tmp"],
            ondelete="SET NULL",
            name="pac_bio_product_metrics_to_run_fk",
        ),
        Index(
            "pac_bio_metrics_product",
            "id_pac_bio_tmp",
            "id_pac_bio_rw_metrics_tmp",
            unique=True,
        ),
        Index("pac_bio_pr_metrics_id_product", "id_pac_bio_product", unique=True),
        Index("pac_bio_pr_metrics_to_rwm_fk", "id_pac_bio_rw_metrics_tmp"),
        Index("pb_product_qc_index", "qc"),
        {
            "comment": "A linking table for the pac_bio_run and pac_bio_run_well_metrics "
            "tables with a potential for adding per-product QC data",
            "mysql_collate": "utf8_unicode_ci",
        },
    )

    id_pac_bio_pr_metrics_tmp: Mapped[int] = mapped_column(
        Integer, primary_key=True, autoincrement=True
    )
    id_pac_bio_rw_metrics_tmp: Mapped[int] = mapped_column(
        Integer,
        nullable=False,
        comment="PacBio run well metrics id, see "
        '"pac_bio_run_well_metrics.id_pac_bio_rw_metrics_tmp"',
    )
    id_pac_bio_product: Mapped[str] = mapped_column(
        CHAR(64), nullable=False, comment="Product id"
    )
    id_pac_bio_tmp: Mapped[Optional[int]] = mapped_column(
        Integer, comment='PacBio run id, see "pac_bio_run.id_pac_bio_tmp"'
    )
    qc: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="The final QC outcome of the product as 0(failed), 1(passed) or NULL",
    )
    hifi_read_bases: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="The number of HiFi bases"
    )
    hifi_num_reads: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The number of HiFi reads"
    )
    hifi_read_length_mean: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The mean HiFi read length"
    )
    barcode4deplexing: Mapped[Optional[str]] = mapped_column(
        String(62),
        comment="The barcode recorded in producing deplexed metrics for this product",
    )
    barcode_quality_score_mean: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="The mean barcode HiFi quality score"
    )
    hifi_bases_percent: Mapped[Optional[float]] = mapped_column(
        Float,
        comment="The HiFi bases expressed as a percentage of the total HiFi bases",
    )
    last_changed: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"),
        comment="Date this record was created or changed",
    )

    pac_bio_run_well_metrics: Mapped["PacBioRunWellMetrics"] = relationship(
        "PacBioRunWellMetrics", back_populates="pac_bio_product_metrics"
    )
    pac_bio_run: Mapped["PacBioRun"] = relationship(
        "PacBioRun", back_populates="pac_bio_product_metrics"
    )


class PacBioRunWellMetrics(Base):
    __tablename__ = "pac_bio_run_well_metrics"
    __table_args__ = (
        Index(
            "pac_bio_metrics_run_well",
            "pac_bio_run_name",
            "well_label",
            "plate_number",
            unique=True,
        ),
        Index("pac_bio_rw_metrics_id_product", "id_pac_bio_product", unique=True),
        Index("pb_rw_qc_date_index", "qc_seq_date"),
        Index("pb_rw_qc_state_index", "qc_seq_state", "qc_seq_state_is_final"),
        Index("pbrw_ccs_execmode_index", "ccs_execution_mode"),
        Index("pbrw_movie_name_index", "movie_name"),
        Index("pbrw_run_complete_index", "run_complete"),
        Index("pbrw_well_complete_index", "well_complete"),
        {
            "comment": "Status and run information by well and some basic QC data from "
            "SMRT Link",
            "mysql_collate": "utf8_unicode_ci",
        },
    )

    id_pac_bio_rw_metrics_tmp: Mapped[int] = mapped_column(
        Integer, primary_key=True, autoincrement=True
    )
    id_pac_bio_product: Mapped[str] = mapped_column(
        CHAR(64), nullable=False, comment="Product id"
    )
    pac_bio_run_name: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="Lims specific identifier for the pacbio run",
    )
    well_label: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The well identifier for the plate, A1-H12",
    )
    instrument_type: Mapped[str] = mapped_column(
        VARCHAR(32), nullable=False, comment="The instrument type e.g. Sequel"
    )
    plate_number: Mapped[Optional[int]] = mapped_column(
        Integer,
        comment="The number of the plate that goes onto the Revio sequencing "
        "machine. Necessary as an identifier for multi-plate support.",
    )
    qc_seq_state: Mapped[Optional[str]] = mapped_column(
        String(255), comment="Current sequencing QC state"
    )
    qc_seq_state_is_final: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="A flag marking the sequencing QC state as final (1) or not final (0)",
    )
    qc_seq_date: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="The date the current sequencing QC state was assigned"
    )
    qc_seq: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="The final sequencing QC outcome as 0(failed), 1(passed) or NULL",
    )
    instrument_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32), comment="The instrument name e.g. SQ54097"
    )
    chip_type: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32), comment="The chip type e.g. 8mChip"
    )
    sl_hostname: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="SMRT Link server hostname"
    )
    sl_run_uuid: Mapped[Optional[str]] = mapped_column(
        VARCHAR(36), comment="SMRT Link specific run uuid"
    )
    sl_ccs_uuid: Mapped[Optional[str]] = mapped_column(
        VARCHAR(36), comment="SMRT Link specific ccs dataset uuid"
    )
    ts_run_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32), comment="The PacBio run name"
    )
    movie_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32), comment="The PacBio movie name"
    )
    movie_minutes: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Movie time (collection time) in minutes"
    )
    created_by: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32), comment="Created by user name recorded in SMRT Link"
    )
    binding_kit: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Binding kit version"
    )
    sequencing_kit: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Sequencing kit version"
    )
    sequencing_kit_lot_number: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Sequencing Kit lot number"
    )
    cell_lot_number: Mapped[Optional[str]] = mapped_column(
        String(32), comment="SMRT Cell Lot Number"
    )
    ccs_execution_mode: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32),
        comment="The PacBio ccs exection mode e.g. OnInstument, OffInstument or None",
    )
    demultiplex_mode: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32),
        comment="Demultiplexing mode e.g. OnInstument, OffInstument or None",
    )
    include_kinetics: Mapped[Optional[int]] = mapped_column(
        TINYINT, comment="Include kinetics information where ccs is run"
    )
    hifi_only_reads: Mapped[Optional[int]] = mapped_column(
        TINYINT,
        comment="CCS was run on the instrument and only HiFi reads were "
        "included in the export from the instrument",
    )
    heteroduplex_analysis: Mapped[Optional[int]] = mapped_column(
        TINYINT,
        comment="Analysis has been run on the instrument to detect and resolve heteroduplex reads",
    )
    loading_conc: Mapped[Optional[float]] = mapped_column(
        Float, comment="SMRT Cell loading concentration (pM)"
    )
    run_start: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of run started"
    )
    run_complete: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of run complete"
    )
    run_transfer_complete: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of run transfer complete"
    )
    run_status: Mapped[Optional[str]] = mapped_column(
        String(32),
        comment="Last recorded status, primarily to explain runs not completed.",
    )
    well_start: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of well started"
    )
    well_complete: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of well complete"
    )
    well_status: Mapped[Optional[str]] = mapped_column(
        String(32),
        comment="Last recorded status, primarily to explain wells not completed.",
    )
    chemistry_sw_version: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32), comment="The PacBio chemistry software version"
    )
    instrument_sw_version: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32), comment="The PacBio instrument software version"
    )
    primary_analysis_sw_version: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32), comment="The PacBio primary analysis software version"
    )
    control_num_reads: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The number of control reads"
    )
    control_concordance_mean: Mapped[Optional[float]] = mapped_column(
        Float(8),
        comment="The average concordance between the control raw reads and the "
        "control reference sequence",
    )
    control_concordance_mode: Mapped[Optional[float]] = mapped_column(
        Float,
        comment="The modal value from the concordance between the control raw "
        "reads and the control reference sequence",
    )
    control_read_length_mean: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The mean polymerase read length of the control reads"
    )
    local_base_rate: Mapped[Optional[float]] = mapped_column(
        Float(8),
        comment="The average base incorporation rate, excluding polymerase pausing events",
    )
    polymerase_read_bases: Mapped[Optional[int]] = mapped_column(
        BIGINT,
        comment="Calculated by multiplying the number of productive (P1) ZMWs "
        "by the mean polymerase read length",
    )
    polymerase_num_reads: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The number of polymerase reads"
    )
    polymerase_read_length_mean: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The mean high-quality read length of all polymerase reads"
    )
    polymerase_read_length_n50: Mapped[Optional[int]] = mapped_column(
        INTEGER,
        comment="Fifty percent of the trimmed read length of all polymerase "
        "reads are longer than this value",
    )
    insert_length_mean: Mapped[Optional[int]] = mapped_column(
        INTEGER,
        comment="The average subread length, considering only the longest "
        "subread from each ZMW",
    )
    insert_length_n50: Mapped[Optional[int]] = mapped_column(
        INTEGER,
        comment="Fifty percent of the subreads are longer than this value when "
        "considering only the longest subread from each ZMW",
    )
    unique_molecular_bases: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="The unique molecular yield in bp"
    )
    productive_zmws_num: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Number of productive ZMWs"
    )
    p0_num: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Number of empty ZMWs with no high quality read detected"
    )
    p1_num: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Number of ZMWs with a high quality read detected"
    )
    p2_num: Mapped[Optional[int]] = mapped_column(
        INTEGER,
        comment="Number of other ZMWs, signal detected but no high quality read",
    )
    adapter_dimer_percent: Mapped[Optional[float]] = mapped_column(
        Float(5),
        comment="The percentage of pre-filter ZMWs which have observed inserts of 0-10 bp",
    )
    short_insert_percent: Mapped[Optional[float]] = mapped_column(
        Float(5),
        comment="The percentage of pre-filter ZMWs which have observed inserts of 11-100 bp",
    )
    hifi_read_bases: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="The number of HiFi bases"
    )
    hifi_num_reads: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The number of HiFi reads"
    )
    hifi_read_length_mean: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The mean HiFi read length"
    )
    hifi_read_quality_median: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="The median HiFi base quality"
    )
    hifi_number_passes_mean: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The mean number of passes per HiFi read"
    )
    hifi_low_quality_read_bases: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="The number of HiFi bases filtered due to low quality (<Q20)"
    )
    hifi_low_quality_num_reads: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The number of HiFi reads filtered due to low quality (<Q20)"
    )
    hifi_low_quality_read_length_mean: Mapped[Optional[int]] = mapped_column(
        INTEGER,
        comment="The mean length of HiFi reads filtered due to low quality (<Q20)",
    )
    hifi_low_quality_read_quality_median: Mapped[Optional[int]] = mapped_column(
        SMALLINT,
        comment="The median base quality of HiFi bases filtered due to low quality (<Q20)",
    )
    hifi_barcoded_reads: Mapped[Optional[int]] = mapped_column(
        INTEGER,
        comment="Number of reads with an expected barcode in demultiplexed HiFi data",
    )
    hifi_bases_in_barcoded_reads: Mapped[Optional[int]] = mapped_column(
        BIGINT,
        comment="Number of bases in reads with an expected barcode in demultiplexed HiFi data",
    )
    last_changed: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"),
        comment="Date this record was created or changed",
    )

    pac_bio_product_metrics: Mapped[List["PacBioProductMetrics"]] = relationship(
        "PacBioProductMetrics", back_populates="pac_bio_run_well_metrics"
    )

    def __repr__(self):
        """Returns a printable representation of the database row"""

        return self._get_row_description(
            ["pac_bio_run_name", "well_label", "plate_number", "id_pac_bio_product"]
        )

    def get_experiment_info(self) -> list[PacBioRun]:
        """Returns a list of PacBioRun mlwh database rows.

        Returns LIMS information about the PacBio experiment
        for this well, one pac_bio_run table row per sample
        (product) in the well.

        If any or all of the pac_bio_product_metrics rows linked
        to this well record are not linked to the pac_bio_run
        table, and empty array is returned, thus preventing incomplete
        data being supplied to the client.
        """
        product_metrics = self.pac_bio_product_metrics
        experiment_info = [
            pbr for pbr in [pm.pac_bio_run for pm in product_metrics] if pbr is not None
        ]
        if len(experiment_info) != len(product_metrics):
            experiment_info = []

        return experiment_info
